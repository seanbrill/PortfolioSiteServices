const { GetConnection } = require("./DatabaseController");
const { GetGeoLocationIP } = require("./RadarController");
const sql = require("mssql");
const { uuid } = require("./utils");
//const http = require("http");

/**
 * Searches the Events table for a name gained from the smtp evemt with the
 * specified ip address. This method allows us to fill in given name for subsequent events
 * after a user has input a name for an ip adress
 * @param {http.incomingRequest} req - the incoming request object
 * @returns {Promise} A promise that resolves with the result of the database operation
 */
module.exports.LogEvent = async function LogEvent(req, event = null) {
  try {
    //generate a unique id
    let event_id = uuid();
    //get host and ip address
    let ip = (req.headers["x-forwarded-for"] || req.headers["x-client-ip"] || req.ip).split(":")[0] ?? "?";
    let host = req.headers["host"] ?? "NULL";
    event = event ?? req.body.event ?? "unkown";

    let givenName = req.body.givenName ?? null;
    if (!givenName || givenName.trim().length === 0) {
      //try to find name from a previous event
      givenName = (await FindName(ip)) ?? "NULL";
    } else {
      //update existing rows to include the given name where givenName was null before
      FillMissingNames(ip, givenName);
    }

    //use radar api to get geo location info
    let geo_response = await GetGeoLocationIP(FormatIP(ip)); //trim a comma for the geo query if present
    let data = null;
    if (geo_response.success && geo_response.response.address) data = geo_response.response.address;

    let lat = data?.latitude ?? 0;
    let lng = data?.longitude ?? 0;
    let city = data?.city ?? "NULL";
    let state = data?.state ?? "NULL";
    let postalCode = data?.postalCode ?? "NULL";
    let country = data?.country ?? "NULL";
    let dma = data?.dma ?? "NULL";
    let dmaCode = data?.dmaCode ?? 0;

    //capture time of the event
    let timestamp = new Date().toISOString();

    await InsertEvent(event_id, ip, host, event, givenName, lat, lng, city, state, postalCode, country, dma, dmaCode, timestamp);
  } catch (error) {
    return error.toString();
  }
};

/**
 *In the event that a proxy is being used we need to get the last ip from the trace
 * @param {string} ip - The ip address of the incomming request
 */
function FormatIP(ip) {
  if (ip.includes(",")) {
    return ip.split(",").pop().trim();
  } else {
    return ip;
  }
}

/**
 * Searches the Events table for a name gained from the smtp evemt with the
 * specified ip address. This method allows us to fill in given name for subsequent events
 * after a user has input a name for an ip adress
 * @param {string} ip - The ip address of the incomming request
 * @returns {Promise} A promise that resolves with the result of the database operation
 */
function FindName(ip) {
  return new Promise(async (resolve) => {
    try {
      let connection = await GetConnection();
      if (!connection) return resolve({ success: false, error: "not connected to the database" });
      let results = await sql.query(`select givenName from Events where ip='${ip}'`);
      if (!results.error) {
        return resolve(results.recordset[0].givenName);
      }
    } catch (error) {
      return resolve(null);
    }
  });
}

/**
 * updates existing rows in the Events table to include the new givenName where previously null
 * @param {string} ip - The ip address of the incomming request
 * @param {string} givenName - The given name to update existing rows with
 * @returns {Promise} A promise that resolves with the result of the database operation
 */
function FillMissingNames(ip, givenName) {
  return new Promise(async (resolve) => {
    try {
      let connection = await GetConnection();
      if (!connection) return resolve({ success: false, error: "not connected to the database" });

      let query = `update Events set givenName=@givenName where ip=@ip`;

      const request = connection.request();
      request.input("ip", sql.VarChar(255), ip);
      request.input("givenName", sql.VarChar(255), givenName);

      request
        .query(query)
        .then((result) => {
          return resolve({ success: true, inserted: result.rowsAffected[0] });
        })
        .catch((error) => {
          return resolve({ success: false, error: error.message });
        });
    } catch (error) {
      return resolve({ success: false, error: error.message });
    }
  });
}

/**
 * Inserts an event into the Events table most geo data from the request is generated from Radar api
 * given name is cross referenced or gained from the smtp event generated by contact me
 * @param {string} id - The generated uuid
 * @param {string} ip - The ip address
 * @param {string} host - The request host
 * @param {string} event - The name of the logged event
 * @param {string} givenName - The name of the person submitting the request -- can be null or gained from cross referencing other requests
 * @param {string} lat - The latitude of the user gained from the ip address
 * @param {string} lng - The longitude of the user gained from the ip address
 * @param {string} city - The vity of the user gained from the ip address
 * @param {string} state - The state of the user gained from the ip address
 * @param {string} postalCode - The postalCode of the user gained from the ip address
 * @param {string} country - The country of the user gained from the ip address
 * @param {string} dma - designated market area of the ip address
 * @param {number} dmaCode - designated market area of the ip address
 * @param {number} timestamp - time in milliseconds of the request
 * @returns {Promise} A promise that resolves with the result of the database operation
 */
function InsertEvent(id, ip, host, event, givenName, lat, lng, city, state, postalCode, country, dma, dmaCode, timestamp) {
  return new Promise(async (resolve) => {
    try {
      let connection = await GetConnection();
      if (!connection) return resolve({ success: false, error: "not connected to the database" });
      let query = `insert into Events (id,ip,host,event,givenName,lat,lng,geocode,city,state,country,postalCode,dma,dmaCode,timestamp)
        values(@id,@ip,@host,@event,@givenName,@lat,@lng,geography::Point(@lat, @lng, 4326),@city,@state,@country,@postalCode,@dma,@dmaCode,@timestamp)`;

      const request = connection.request();
      request.input("id", sql.VarChar(255), id);
      request.input("ip", sql.VarChar(255), ip);
      request.input("host", sql.VarChar(255), host);
      request.input("event", sql.VarChar(255), event);
      request.input("givenName", sql.VarChar(255), givenName);
      request.input("lat", sql.Float, lat);
      request.input("lng", sql.Float, lng);
      request.input("city", sql.VarChar(255), city);
      request.input("state", sql.VarChar(255), state);
      request.input("postalCode", sql.VarChar(255), postalCode);
      request.input("country", sql.VarChar(255), country);
      request.input("dma", sql.VarChar(255), dma);
      request.input("dmaCode", sql.BigInt, dmaCode);
      request.input("timestamp", sql.DateTime, timestamp);

      request
        .query(query)
        .then((result) => {
          return resolve({ success: true, inserted: result.rowsAffected[0] });
        })
        .catch((error) => {
          return resolve({ success: false, error: error.message });
        });
    } catch (error) {
      return resolve({ success: false, error });
    }
  });
}
